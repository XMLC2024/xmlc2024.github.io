{"posts":[{"title":"Gridea & github 博客","content":"前言 本教程基于《纯免费》与《纯0基础》的观念。 如果你不想尝试这种《麻烦》的方法，你已经可以退出去了 目录 Gridea下载 Github Pages 评论系统 Gridea ##如果您很有《实力》可以跳过此步骤 您可以点击此处打开Gridea - 官方网站，但是这是非开源的Gridea版本，请点击“开源客户端”下载免费版本。或Windows用户点击此处直接下载Gridea - Windows 你也可以点击这里，打开GITHUB上的Gridea Gridea - GITHUB GITHUB PAGES 开始前，请点击Github - 网址 如果无法正常连接，请往下看 Github 无法正常连接 这是非常正常的一种情况，有两种解决办法 Magic 使用工具Watt Toolkit的Github加速解决此问题，如果你不会，请自行询问一个叫百度的东西,或者直接跳转到百度 回归主题 如果你成功进去了GITHUB,请您先注册一个账号，如果你也不会，麻烦测试一下英语并询问百度如何注册 注册成功后,请: 点击右上角的加号 选择new repository创建新的存储库 填写Repository name存储库名称，为“你的用户名+github.io&quot; 例子:example.github.io 选择Public 点击绿色小按钮 如果你成功进入了界面，那么你已经成功1/4了! GITHUB APP 接下来，还有东西正在等着你！ 点击此链接[创建GITHUB APP]来创建一个GITHUB APP。 啥也不用动，直接确认即可。 点击[Github APP主页]，找到你刚刚创建的APP。 将Client ID与Client secrets复制好。 注意：Client secrets一旦丢失，没有后来！ 如果丢失，你只能重开，一定保存好! 配置Gridea 打开Gridea,选择远程。 基础配置: 平台选择Github Pages,域名填写:你的名字+.github.io 不含https:// 仓库名称同你的名字+.github.io 分支为master不用动，默认的 仓库用户名就是你的用户名 令牌(Token):Github TOKEN,Note随便写，勾选repo所有内容，划到最底部，生成即可。 检测远程连接 如果显示成功,您可以点击保存并继续 如果失败，请你检查你的操作，如果仍有问题，划到最底部进行留言。 到此为止，最基础的已经配置完毕。 评论系统 ","link":"https://xmlc2024.github.io/post/gridea-and-github-bo-ke/"},{"title":"CodeForces  [CF52A 123-sequence]","content":"洛 谷 入 门 基 础 题 - CF52A 刷 A C 必 备 CF52A CODEFORCES 好几种做法，你自己选一种: 第一种做法[1] ** 超小声:如果你是直奔答案的，或许可以尝试点击一下[1] 定义一个大小为444的变量aaa 定义一个变量numnumnum存储数据个数 定义一个lll临时存储输入 定义一个maxxmaxxmaxx存储a1,a2,a3a_1,a_2,a_3a1​,a2​,a3​的最大值 做法: 输入数据，挑选最大值(相同数据最多的值) 用总数据-最大值 #include &lt;stdio.h&gt; int a[4], num, l, maxx; int max(int a, int b) { if (a &gt; b) return a; else return b; } int main() { scanf(&quot;%d&quot;, &amp;num); for (int i = 1; i &lt;= num; i++) { scanf(&quot;%d&quot;, &amp;l); a[l]++; maxx = max(a[l], maxx); } printf(&quot;%d&quot;, num - maxx); } ↩︎ ","link":"https://xmlc2024.github.io/post/codeforces-cf52a-123-sequence/"},{"title":"评论区域","content":"如果你比较闲，可以在这里聊天~ 支持Markdown $ 你可以在这里随便评论 $ ","link":"https://xmlc2024.github.io/post/ping-lun-qu-yu/"},{"title":"CodeForces CF677A","content":"CodeForces CF677A 其实只要稍微使用以下你智慧的脑袋，你应该知道，这用不到数组，直接变量判断就可以了 #include &lt;bits/stdc++.h&gt; using namespace std; int n, h, a, ans; int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;h); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a); if (a &gt; h) ans += 2; else ans += 1; } printf(&quot;%d&quot;, ans); } ","link":"https://xmlc2024.github.io/post/codeforces-cf677a/"},{"title":"CodeFoces CF1B 半成品题解","content":"点击此处跳转到此题 - 洛谷 或许如果你很懒，看这里也可以: Spreadsheets 题面翻译 人们常用的电子表格软件(比如: Excel)采用如下所述的坐标系统: 第一列被标为 A，第二列为 B，以此类推，第 262626 列为 Z。接下来为由两个字母构成的列号: 第 272727 列为 AA，第 282828 列为 AB ⋯\\cdots⋯ 在标为 ZZ 的列之后则由三个字母构成列号，如此类推。 行号为从 111 开始的整数。 单元格的坐标由列号和行号连接而成。比如，BC23 表示位于第 555555 列 232323 行的单元格。 有时也会采用被称为 RXCY 的坐标系统，其中 XXX 与 YYY 为整数，坐标 (X(X(X,Y)Y)Y) 直接描述了对应单元格的位置。比如，R23C55 即为前面所述的单元格。 您的任务是编写一个程序，将所给的单元格坐标转换为另一种坐标系统下面的形式。 输入 第一行一个整数 nnn (1(1(1 ≤\\le≤ nnn ≤\\le≤ 105)10^5)105) 表示将会输入的坐标的数量。 接下来 nnn 行，每行一个坐标。 注意: 每个坐标都是正确的。此外不会出现行号或列号大于 10610^6106 的单元格。 输出 nnn 行，每行一个被转换的坐标。 输出 nnn 行，每行一个被转换的坐标。 样例 #1 样例输入 #1 2 R23C55 BC23 样例输出 #1 BC23 R23C55 ###解题方法:函数 首先，BC23 转换到需要 R35C55 识别文字和数字 将其转换为两个 int 类型的数据，分别为X,Y 创建一个字符串，重新拼接为R+X+C+Y 实例代码如下，实现了前两个步骤 int to_RXCY(string s) { int J=1; //*单次进制X int JJ=1; //* 单次进制Y for(int i=0;i&lt;s.length();i++) { if(J==27) J=26; if(s[i]&gt;='A' &amp;&amp; s[i]&lt;='Z') {T+=s[i],X=X*J+(int(s[i])-64);J+=26;} if(s[i]&gt;='0' &amp;&amp; s[i]&lt;='9') Y=Y*JJ + (int(s[i])-48),JJ*=10; } } ","link":"https://xmlc2024.github.io/post/codefoces-cf1b-ban-cheng-pin-ti-jie/"}]}